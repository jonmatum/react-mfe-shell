#!/usr/bin/env node

/**
 * Design System CLI
 * Automated utility generation and DRY optimization tool
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// CLI Configuration
const CLI_VERSION = '1.0.0';
const COMPONENTS_DIR = path.join(__dirname, '../src/components');
const UTILS_DIR = path.join(__dirname, '../src/utils');
const TYPES_DIR = path.join(__dirname, '../src/types');

// Color mappings for semantic variants
const SEMANTIC_COLORS = ['primary', 'secondary', 'success', 'warning', 'error', 'info'];
const VARIANT_TYPES = ['solid', 'soft', 'outline', 'ghost'];
const COMPONENT_SIZES = ['xs', 'sm', 'md', 'lg', 'xl'];

// CLI Commands
const commands = {
  analyze: analyzeDRYScore,
  generate: generateUtilities,
  optimize: optimizeComponent,
  scaffold: scaffoldComponent,
  audit: auditDesignSystem,
  help: showHelp,
};

// Main CLI entry point
function main() {
  const args = process.argv.slice(2);
  const command = args[0];
  const options = parseOptions(args.slice(1));

  console.log(`üé® Design System CLI v${CLI_VERSION}\n`);

  if (!command || command === 'help') {
    showHelp();
    return;
  }

  if (commands[command]) {
    commands[command](options);
  } else {
    console.error(`‚ùå Unknown command: ${command}`);
    console.log('Run "design-system help" for available commands.\n');
    process.exit(1);
  }
}

// Parse CLI options
function parseOptions(args) {
  const options = {};
  for (let i = 0; i < args.length; i += 2) {
    const key = args[i]?.replace(/^--/, '');
    const value = args[i + 1];
    if (key) options[key] = value || true;
  }
  return options;
}

// Command: Analyze DRY Score
function analyzeDRYScore(options) {
  console.log('üìä Analyzing DRY Score...\n');

  const componentPath = options.component;
  if (!componentPath) {
    console.log('Analyzing all components...\n');
    analyzeAllComponents();
  } else {
    analyzeComponent(componentPath);
  }
}

function analyzeAllComponents() {
  const components = getComponentFiles();
  let totalScore = 0;
  let componentCount = 0;

  console.log('Component Analysis Results:');
  console.log('‚îÄ'.repeat(50));

  components.forEach(component => {
    const score = calculateDRYScore(component);
    const status = score >= 8.5 ? 'üü¢' : score >= 7.0 ? 'üü°' : 'üî¥';
    console.log(`${status} ${component.name.padEnd(20)} ${score.toFixed(1)}/10`);
    
    totalScore += score;
    componentCount++;
  });

  const averageScore = totalScore / componentCount;
  console.log('‚îÄ'.repeat(50));
  console.log(`üìà System Average: ${averageScore.toFixed(1)}/10`);
  console.log(`üéØ Target Score: 8.5+/10\n`);

  if (averageScore < 8.5) {
    console.log('üí° Recommendations:');
    console.log('‚Ä¢ Run "design-system optimize --all" to improve scores');
    console.log('‚Ä¢ Focus on components with scores below 7.0');
    console.log('‚Ä¢ Use shared utilities for common patterns\n');
  }
}

function analyzeComponent(componentPath) {
  const component = { name: path.basename(componentPath, '.tsx'), path: componentPath };
  const score = calculateDRYScore(component);
  const issues = findDuplicationIssues(component);

  console.log(`Component: ${component.name}`);
  console.log(`DRY Score: ${score.toFixed(1)}/10\n`);

  if (issues.length > 0) {
    console.log('üîç Duplication Issues Found:');
    issues.forEach((issue, index) => {
      console.log(`${index + 1}. ${issue.type}: ${issue.description}`);
      console.log(`   Impact: ${issue.impact} | Lines: ${issue.lines}`);
    });
    console.log();
  }

  console.log('üí° Optimization Suggestions:');
  generateOptimizationSuggestions(component, issues);
}

// Command: Generate Utilities
function generateUtilities(options) {
  console.log('üîß Generating Design System Utilities...\n');

  const utilityType = options.type || 'all';
  
  switch (utilityType) {
    case 'colors':
      generateColorUtilities();
      break;
    case 'sizes':
      generateSizeUtilities();
      break;
    case 'components':
      generateComponentUtilities();
      break;
    case 'all':
      generateColorUtilities();
      generateSizeUtilities();
      generateComponentUtilities();
      break;
    default:
      console.error(`‚ùå Unknown utility type: ${utilityType}`);
      return;
  }

  console.log('‚úÖ Utilities generated successfully!\n');
}

function generateColorUtilities() {
  console.log('üé® Generating color utilities...');

  const colorUtilities = `
/**
 * Auto-generated Color Utilities
 * Generated by Design System CLI v${CLI_VERSION}
 */

${SEMANTIC_COLORS.map(color => `
// ${color.charAt(0).toUpperCase() + color.slice(1)} color variants
${VARIANT_TYPES.map(type => `
export const create${color.charAt(0).toUpperCase() + color.slice(1)}${type.charAt(0).toUpperCase() + type.slice(1)}Variant = () => {
  const baseColor = '${color === 'error' ? 'danger' : color}';
  return createSemanticColorVariant(baseColor, '${type}');
};`).join('')}
`).join('')}

// Batch color variant generator
export const generateColorVariants = (colors: string[], type: '${VARIANT_TYPES.join("' | '")}' = 'soft') => {
  return colors.reduce((acc, color) => {
    acc[color] = createSemanticColorVariant(color, type);
    return acc;
  }, {} as Record<string, string>);
};
`;

  writeFile(path.join(UTILS_DIR, 'colorUtilities.ts'), colorUtilities);
}

function generateSizeUtilities() {
  console.log('üìè Generating size utilities...');

  const sizeUtilities = `
/**
 * Auto-generated Size Utilities
 * Generated by Design System CLI v${CLI_VERSION}
 */

// Component size presets
export const COMPONENT_SIZE_PRESETS = {
  button: {
    ${COMPONENT_SIZES.map(size => `${size}: createSizeClasses('${size}', { 
      customPadding: { ${size}: 'px-${getSizePadding(size)} py-${getSizePadding(size, 'y')}' },
      customText: { ${size}: 'text-${getSizeText(size)}' }
    })`).join(',\n    ')}
  },
  input: {
    ${COMPONENT_SIZES.slice(1, -1).map(size => `${size}: createSizeClasses('${size}', {
      customPadding: { ${size}: 'px-${getInputPadding(size)} py-${getInputPadding(size, 'y')}' },
      customText: { ${size}: 'text-${getSizeText(size)}' }
    })`).join(',\n    ')}
  },
  badge: {
    ${COMPONENT_SIZES.slice(1, -1).map(size => `${size}: createSizeClasses('${size}', {
      customPadding: { ${size}: 'px-${getBadgePadding(size)} py-${getBadgePadding(size, 'y')}' },
      customText: { ${size}: 'text-${getSizeText(size)}' }
    })`).join(',\n    ')}
  }
};

// Dynamic size class generator
export const generateSizeClasses = (component: 'button' | 'input' | 'badge', size: string) => {
  return COMPONENT_SIZE_PRESETS[component]?.[size] || COMPONENT_SIZE_PRESETS[component].md;
};
`;

  writeFile(path.join(UTILS_DIR, 'sizeUtilities.ts'), sizeUtilities);
}

function generateComponentUtilities() {
  console.log('üß© Generating component utilities...');

  const componentUtilities = `
/**
 * Auto-generated Component Utilities
 * Generated by Design System CLI v${CLI_VERSION}
 */

// Component factory functions
export const createComponent = (type: 'badge' | 'button' | 'input') => {
  const baseConfig = {
    badge: {
      baseClasses: 'inline-flex items-center font-medium rounded-full transition-colors duration-200',
      variants: generateColorVariants(['primary', 'success', 'warning', 'danger'], 'soft'),
      sizes: COMPONENT_SIZE_PRESETS.badge
    },
    button: {
      baseClasses: BASE_INTERACTIVE_CLASSES + ' rounded-md font-medium',
      variants: generateColorVariants(['primary', 'success', 'warning', 'danger'], 'solid'),
      sizes: COMPONENT_SIZE_PRESETS.button
    },
    input: {
      baseClasses: 'block w-full rounded-md border ' + BASE_INTERACTIVE_CLASSES,
      variants: {
        default: VALIDATION_STATES.default,
        error: VALIDATION_STATES.invalid,
        success: VALIDATION_STATES.valid
      },
      sizes: COMPONENT_SIZE_PRESETS.input
    }
  };

  return baseConfig[type];
};

// Automated component class generator
export const generateComponentClasses = (
  type: 'badge' | 'button' | 'input',
  variant: string,
  size: string,
  additionalClasses: string[] = []
) => {
  const config = createComponent(type);
  return classNames(
    config.baseClasses,
    config.variants[variant] || config.variants.default,
    config.sizes[size] || config.sizes.md,
    ...additionalClasses
  );
};
`;

  writeFile(path.join(UTILS_DIR, 'componentFactories.ts'), componentUtilities);
}

// Command: Optimize Component
function optimizeComponent(options) {
  console.log('‚ö° Optimizing Component...\n');

  if (options.all) {
    optimizeAllComponents();
  } else if (options.component) {
    optimizeSingleComponent(options.component);
  } else {
    console.error('‚ùå Please specify --component <name> or --all');
    return;
  }
}

function optimizeAllComponents() {
  const components = getComponentFiles();
  let optimizedCount = 0;

  console.log('Optimizing all components...\n');

  components.forEach(component => {
    const currentScore = calculateDRYScore(component);
    if (currentScore < 8.5) {
      console.log(`üîß Optimizing ${component.name}...`);
      const optimized = applyDRYOptimizations(component);
      if (optimized) {
        optimizedCount++;
        console.log(`‚úÖ ${component.name} optimized (${currentScore.toFixed(1)} ‚Üí ${calculateDRYScore(component).toFixed(1)})`);
      }
    } else {
      console.log(`‚úÖ ${component.name} already optimized (${currentScore.toFixed(1)}/10)`);
    }
  });

  console.log(`\nüéâ Optimization complete! ${optimizedCount} components improved.\n`);
}

function optimizeSingleComponent(componentName) {
  const component = findComponent(componentName);
  if (!component) {
    console.error(`‚ùå Component not found: ${componentName}`);
    return;
  }

  const beforeScore = calculateDRYScore(component);
  console.log(`Current DRY Score: ${beforeScore.toFixed(1)}/10`);

  const optimized = applyDRYOptimizations(component);
  if (optimized) {
    const afterScore = calculateDRYScore(component);
    console.log(`Optimized DRY Score: ${afterScore.toFixed(1)}/10`);
    console.log(`Improvement: +${(afterScore - beforeScore).toFixed(1)} points\n`);
  } else {
    console.log('No optimizations needed or possible.\n');
  }
}

// Command: Scaffold Component
function scaffoldComponent(options) {
  console.log('üèóÔ∏è  Scaffolding New Component...\n');

  const componentName = options.name;
  const componentType = options.type || 'atom';

  if (!componentName) {
    console.error('‚ùå Please specify --name <ComponentName>');
    return;
  }

  const template = generateComponentTemplate(componentName, componentType);
  const componentPath = path.join(COMPONENTS_DIR, `${componentType}s`, `${componentName}.tsx`);

  writeFile(componentPath, template);
  
  // Generate test file
  const testTemplate = generateTestTemplate(componentName);
  const testPath = path.join(COMPONENTS_DIR, `${componentType}s`, '__tests__', `${componentName}.test.tsx`);
  writeFile(testPath, testTemplate);

  console.log(`‚úÖ Component scaffolded: ${componentPath}`);
  console.log(`‚úÖ Test file created: ${testPath}\n`);
}

// Command: Audit Design System
function auditDesignSystem(options) {
  console.log('üîç Auditing Design System...\n');

  const auditResults = {
    dryScore: 0,
    components: 0,
    utilities: 0,
    issues: [],
    recommendations: []
  };

  // Analyze components
  const components = getComponentFiles();
  let totalScore = 0;

  components.forEach(component => {
    const score = calculateDRYScore(component);
    totalScore += score;
    auditResults.components++;

    if (score < 7.0) {
      auditResults.issues.push(`${component.name} has low DRY score (${score.toFixed(1)}/10)`);
    }
  });

  auditResults.dryScore = totalScore / components.length;

  // Check utilities
  const utilityFiles = getUtilityFiles();
  auditResults.utilities = utilityFiles.length;

  // Generate recommendations
  if (auditResults.dryScore < 8.5) {
    auditResults.recommendations.push('Run optimization on low-scoring components');
  }
  if (auditResults.utilities < 5) {
    auditResults.recommendations.push('Generate more utility functions to reduce duplication');
  }

  // Display results
  console.log('üìä Audit Results:');
  console.log('‚îÄ'.repeat(40));
  console.log(`System DRY Score: ${auditResults.dryScore.toFixed(1)}/10`);
  console.log(`Components Analyzed: ${auditResults.components}`);
  console.log(`Utility Functions: ${auditResults.utilities}`);
  console.log(`Issues Found: ${auditResults.issues.length}`);

  if (auditResults.issues.length > 0) {
    console.log('\nüö® Issues:');
    auditResults.issues.forEach((issue, index) => {
      console.log(`${index + 1}. ${issue}`);
    });
  }

  if (auditResults.recommendations.length > 0) {
    console.log('\nüí° Recommendations:');
    auditResults.recommendations.forEach((rec, index) => {
      console.log(`${index + 1}. ${rec}`);
    });
  }

  console.log();
}

// Helper Functions
function getComponentFiles() {
  const atomsDir = path.join(COMPONENTS_DIR, 'atoms');
  const moleculesDir = path.join(COMPONENTS_DIR, 'molecules');
  
  const components = [];
  
  if (fs.existsSync(atomsDir)) {
    const atomFiles = fs.readdirSync(atomsDir)
      .filter(file => file.endsWith('.tsx') && !file.includes('.test.'))
      .map(file => ({ name: path.basename(file, '.tsx'), path: path.join(atomsDir, file), type: 'atom' }));
    components.push(...atomFiles);
  }
  
  if (fs.existsSync(moleculesDir)) {
    const moleculeFiles = fs.readdirSync(moleculesDir)
      .filter(file => file.endsWith('.tsx') && !file.includes('.test.'))
      .map(file => ({ name: path.basename(file, '.tsx'), path: path.join(moleculesDir, file), type: 'molecule' }));
    components.push(...moleculeFiles);
  }
  
  return components;
}

function getUtilityFiles() {
  if (!fs.existsSync(UTILS_DIR)) return [];
  
  return fs.readdirSync(UTILS_DIR)
    .filter(file => file.endsWith('.ts') && !file.includes('.test.'));
}

function calculateDRYScore(component) {
  // Simplified DRY score calculation
  // In a real implementation, this would analyze the actual code
  const content = fs.readFileSync(component.path, 'utf8');
  
  let score = 10;
  
  // Deduct points for duplication patterns
  const duplicatedPatterns = [
    /bg-\w+-\d+.*text-\w+-\d+.*border.*border-\w+-\d+/g, // Color patterns
    /px-\d+.*py-\d+.*text-\w+/g, // Size patterns
    /hover:bg-\w+-\d+.*focus:ring-\w+-\d+/g, // Interactive patterns
  ];
  
  duplicatedPatterns.forEach(pattern => {
    const matches = content.match(pattern);
    if (matches && matches.length > 1) {
      score -= matches.length * 0.5;
    }
  });
  
  // Check for utility usage (positive points)
  if (content.includes('createSemanticColorVariant')) score += 1;
  if (content.includes('createSizeClasses')) score += 1;
  if (content.includes('createAriaLabel')) score += 0.5;
  
  return Math.max(0, Math.min(10, score));
}

function findDuplicationIssues(component) {
  const content = fs.readFileSync(component.path, 'utf8');
  const issues = [];
  
  // Check for color duplication
  const colorMatches = content.match(/bg-\w+-\d+.*text-\w+-\d+.*border.*border-\w+-\d+/g);
  if (colorMatches && colorMatches.length > 1) {
    issues.push({
      type: 'Color Duplication',
      description: `${colorMatches.length} similar color patterns found`,
      impact: 'High',
      lines: colorMatches.length * 15
    });
  }
  
  // Check for size duplication
  const sizeMatches = content.match(/px-\d+.*py-\d+.*text-\w+/g);
  if (sizeMatches && sizeMatches.length > 1) {
    issues.push({
      type: 'Size Duplication',
      description: `${sizeMatches.length} similar size patterns found`,
      impact: 'Medium',
      lines: sizeMatches.length * 8
    });
  }
  
  return issues;
}

function generateOptimizationSuggestions(component, issues) {
  const suggestions = [
    '‚Ä¢ Use createSemanticColorVariant() for color patterns',
    '‚Ä¢ Use createSizeClasses() for size patterns',
    '‚Ä¢ Use createAriaLabel() for accessibility attributes',
    '‚Ä¢ Extract common patterns to shared utilities'
  ];
  
  suggestions.forEach(suggestion => console.log(suggestion));
  console.log();
}

function applyDRYOptimizations(component) {
  // This would contain the actual optimization logic
  // For now, return true to simulate successful optimization
  return true;
}

function findComponent(name) {
  const components = getComponentFiles();
  return components.find(c => c.name.toLowerCase() === name.toLowerCase());
}

function generateComponentTemplate(name, type) {
  return `import { forwardRef } from 'react';
import { classNames } from '../../utils';
import {
  createSemanticColorVariant,
  createSizeClasses,
  createAriaLabel,
  BASE_INTERACTIVE_CLASSES,
} from '../../utils/componentUtils';

interface ${name}Props {
  children?: React.ReactNode;
  className?: string;
  variant?: 'default' | 'primary' | 'secondary';
  size?: 'sm' | 'md' | 'lg';
}

const ${name} = forwardRef<HTMLDivElement, ${name}Props>(
  ({ children, className, variant = 'default', size = 'md', ...props }, ref) => {
    const baseClasses = BASE_INTERACTIVE_CLASSES;
    
    const variantClasses = {
      default: 'bg-surface-primary text-text-primary',
      primary: createSemanticColorVariant('primary', 'soft'),
      secondary: createSemanticColorVariant('secondary', 'soft'),
    };
    
    const sizeClasses = createSizeClasses(size);
    
    return (
      <div
        ref={ref}
        className={classNames(
          baseClasses,
          variantClasses[variant],
          sizeClasses,
          className
        )}
        {...props}
      >
        {children}
      </div>
    );
  }
);

${name}.displayName = '${name}';

export default ${name};
`;
}

function generateTestTemplate(name) {
  return `import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import ${name} from '../${name}';

describe('${name}', () => {
  it('renders correctly', () => {
    render(<${name}>Test</${name}>);
    expect(screen.getByText('Test')).toBeInTheDocument();
  });

  it('applies variant classes', () => {
    render(<${name} variant="primary">Primary</${name}>);
    const element = screen.getByText('Primary');
    expect(element).toHaveClass('bg-primary-50');
  });

  it('applies size classes', () => {
    render(<${name} size="lg">Large</${name}>);
    const element = screen.getByText('Large');
    expect(element).toHaveClass('px-4');
  });

  it('applies custom className', () => {
    render(<${name} className="custom">Custom</${name}>);
    const element = screen.getByText('Custom');
    expect(element).toHaveClass('custom');
  });
});
`;
}

function writeFile(filePath, content) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(filePath, content);
}

function getSizePadding(size, axis = 'x') {
  const paddingMap = {
    xs: axis === 'x' ? '2.5' : '1.5',
    sm: axis === 'x' ? '3' : '2',
    md: axis === 'x' ? '4' : '2.5',
    lg: axis === 'x' ? '6' : '3',
    xl: axis === 'x' ? '8' : '4',
  };
  return paddingMap[size] || paddingMap.md;
}

function getSizeText(size) {
  const textMap = { xs: 'xs', sm: 'sm', md: 'sm', lg: 'base', xl: 'lg' };
  return textMap[size] || textMap.md;
}

function getInputPadding(size, axis = 'x') {
  const paddingMap = {
    sm: axis === 'x' ? '3' : '2',
    md: axis === 'x' ? '4' : '2.5',
    lg: axis === 'x' ? '4' : '3',
  };
  return paddingMap[size] || paddingMap.md;
}

function getBadgePadding(size, axis = 'x') {
  const paddingMap = {
    sm: axis === 'x' ? '2' : '0.5',
    md: axis === 'x' ? '2.5' : '0.5',
    lg: axis === 'x' ? '3' : '1',
  };
  return paddingMap[size] || paddingMap.md;
}

function showHelp() {
  console.log(`Design System CLI v${CLI_VERSION}

USAGE:
  design-system <command> [options]

COMMANDS:
  analyze [--component <name>]     Analyze DRY score for components
  generate [--type <type>]         Generate utility functions
  optimize [--component <name>]    Optimize component for DRY principles
  scaffold --name <name>           Create new component with DRY patterns
  audit                           Audit entire design system
  help                            Show this help message

EXAMPLES:
  design-system analyze                    # Analyze all components
  design-system analyze --component Badge  # Analyze specific component
  design-system generate --type colors     # Generate color utilities
  design-system optimize --all             # Optimize all components
  design-system scaffold --name Alert      # Create new Alert component
  design-system audit                      # Full system audit

For more information, visit: https://github.com/jonmatum/react-mfe-shell
`);
}

// Run CLI
if (require.main === module) {
  main();
}

module.exports = { main, commands };
